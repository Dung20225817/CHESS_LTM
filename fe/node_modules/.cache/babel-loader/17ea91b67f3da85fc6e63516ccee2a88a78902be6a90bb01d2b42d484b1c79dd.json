{"ast":null,"code":"export class ChessRules {\n  // Kiểm tra quân cờ có phải của player không\n  static isPlayerPiece(piece, playerColor) {\n    if (piece === '.') return false;\n    const isWhite = piece === piece.toUpperCase();\n    return playerColor === 'white' ? isWhite : !isWhite;\n  }\n\n  // Chuyển đổi từ notation (e2) sang position\n  static notationToPosition(notation) {\n    if (notation.length !== 2) return null;\n    const col = notation.charCodeAt(0) - 'a'.charCodeAt(0);\n    const row = 8 - parseInt(notation[1]);\n    if (col < 0 || col > 7 || row < 0 || row > 7) return null;\n    return {\n      row,\n      col\n    };\n  }\n\n  // Chuyển đổi từ position sang notation (e2)\n  static positionToNotation(pos) {\n    const file = String.fromCharCode('a'.charCodeAt(0) + pos.col);\n    const rank = String(8 - pos.row);\n    return `${file}${rank}`;\n  }\n\n  // Lấy quân cờ tại vị trí\n  static getPieceAt(board, pos) {\n    if (pos.row < 0 || pos.row > 7 || pos.col < 0 || pos.col > 7) return '';\n    return board[pos.row][pos.col];\n  }\n\n  // Kiểm tra nước đi hợp lệ (cơ bản)\n  static isValidMove(board, move, playerColor) {\n    const fromPiece = this.getPieceAt(board, move.from);\n    const toPiece = this.getPieceAt(board, move.to);\n\n    // Kiểm tra quân cờ nguồn\n    if (!this.isPlayerPiece(fromPiece, playerColor)) {\n      return {\n        valid: false,\n        error: 'Không phải quân cờ của bạn'\n      };\n    }\n\n    // Không thể ăn quân cờ cùng màu\n    if (toPiece !== '.' && this.isPlayerPiece(toPiece, playerColor)) {\n      return {\n        valid: false,\n        error: 'Không thể ăn quân cờ của mình'\n      };\n    }\n\n    // Kiểm tra theo từng loại quân\n    const pieceType = fromPiece.toLowerCase();\n    let isValid = false;\n    switch (pieceType) {\n      case 'p':\n        isValid = this.isValidPawnMove(board, move, playerColor);\n        break;\n      case 'r':\n        isValid = this.isValidRookMove(board, move);\n        break;\n      case 'n':\n        isValid = this.isValidKnightMove(move);\n        break;\n      case 'b':\n        isValid = this.isValidBishopMove(board, move);\n        break;\n      case 'q':\n        isValid = this.isValidQueenMove(board, move);\n        break;\n      case 'k':\n        isValid = this.isValidKingMove(move);\n        break;\n    }\n    if (!isValid) {\n      return {\n        valid: false,\n        error: 'Nước đi không hợp lệ'\n      };\n    }\n    return {\n      valid: true\n    };\n  }\n\n  // Kiểm tra đường đi có bị chặn không\n  static isPathClear(board, from, to) {\n    const rowDir = Math.sign(to.row - from.row);\n    const colDir = Math.sign(to.col - from.col);\n    let currentRow = from.row + rowDir;\n    let currentCol = from.col + colDir;\n    while (currentRow !== to.row || currentCol !== to.col) {\n      if (board[currentRow][currentCol] !== '.') return false;\n      currentRow += rowDir;\n      currentCol += colDir;\n    }\n    return true;\n  }\n\n  // Tốt (Pawn)\n  static isValidPawnMove(board, move, playerColor) {\n    const direction = playerColor === 'white' ? -1 : 1;\n    const startRow = playerColor === 'white' ? 6 : 1;\n    const rowDiff = move.to.row - move.from.row;\n    const colDiff = Math.abs(move.to.col - move.from.col);\n\n    // Di chuyển thẳng\n    if (colDiff === 0) {\n      if (rowDiff === direction && board[move.to.row][move.to.col] === '.') {\n        return true;\n      }\n      // Nước đầu tiên có thể đi 2 ô\n      if (move.from.row === startRow && rowDiff === 2 * direction) {\n        const middleRow = move.from.row + direction;\n        return board[middleRow][move.from.col] === '.' && board[move.to.row][move.to.col] === '.';\n      }\n    }\n\n    // Ăn chéo\n    if (colDiff === 1 && rowDiff === direction) {\n      return board[move.to.row][move.to.col] !== '.';\n    }\n    return false;\n  }\n\n  // Xe (Rook)\n  static isValidRookMove(board, move) {\n    const rowDiff = Math.abs(move.to.row - move.from.row);\n    const colDiff = Math.abs(move.to.col - move.from.col);\n    if (rowDiff === 0 && colDiff > 0 || colDiff === 0 && rowDiff > 0) {\n      return this.isPathClear(board, move.from, move.to);\n    }\n    return false;\n  }\n\n  // Mã (Knight)\n  static isValidKnightMove(move) {\n    const rowDiff = Math.abs(move.to.row - move.from.row);\n    const colDiff = Math.abs(move.to.col - move.from.col);\n    return rowDiff === 2 && colDiff === 1 || rowDiff === 1 && colDiff === 2;\n  }\n\n  // Tượng (Bishop)\n  static isValidBishopMove(board, move) {\n    const rowDiff = Math.abs(move.to.row - move.from.row);\n    const colDiff = Math.abs(move.to.col - move.from.col);\n    if (rowDiff === colDiff && rowDiff > 0) {\n      return this.isPathClear(board, move.from, move.to);\n    }\n    return false;\n  }\n\n  // Hậu (Queen)\n  static isValidQueenMove(board, move) {\n    return this.isValidRookMove(board, move) || this.isValidBishopMove(board, move);\n  }\n\n  // Vua (King)\n  static isValidKingMove(move) {\n    const rowDiff = Math.abs(move.to.row - move.from.row);\n    const colDiff = Math.abs(move.to.col - move.from.col);\n    return rowDiff <= 1 && colDiff <= 1 && (rowDiff > 0 || colDiff > 0);\n  }\n}","map":{"version":3,"names":["ChessRules","isPlayerPiece","piece","playerColor","isWhite","toUpperCase","notationToPosition","notation","length","col","charCodeAt","row","parseInt","positionToNotation","pos","file","String","fromCharCode","rank","getPieceAt","board","isValidMove","move","fromPiece","from","toPiece","to","valid","error","pieceType","toLowerCase","isValid","isValidPawnMove","isValidRookMove","isValidKnightMove","isValidBishopMove","isValidQueenMove","isValidKingMove","isPathClear","rowDir","Math","sign","colDir","currentRow","currentCol","direction","startRow","rowDiff","colDiff","abs","middleRow"],"sources":["D:/LTM/CHESS/fe/src/components/Broad/chessRules.ts"],"sourcesContent":["export type PieceType = 'K' | 'Q' | 'R' | 'B' | 'N' | 'P' | 'k' | 'q' | 'r' | 'b' | 'n' | 'p' | '.';\r\nexport type Position = { row: number; col: number };\r\nexport type Move = { from: Position; to: Position };\r\n\r\nexport class ChessRules {\r\n  // Kiểm tra quân cờ có phải của player không\r\n  static isPlayerPiece(piece: string, playerColor: 'white' | 'black'): boolean {\r\n    if (piece === '.') return false;\r\n    const isWhite = piece === piece.toUpperCase();\r\n    return playerColor === 'white' ? isWhite : !isWhite;\r\n  }\r\n\r\n  // Chuyển đổi từ notation (e2) sang position\r\n  static notationToPosition(notation: string): Position | null {\r\n    if (notation.length !== 2) return null;\r\n    const col = notation.charCodeAt(0) - 'a'.charCodeAt(0);\r\n    const row = 8 - parseInt(notation[1]);\r\n    if (col < 0 || col > 7 || row < 0 || row > 7) return null;\r\n    return { row, col };\r\n  }\r\n\r\n  // Chuyển đổi từ position sang notation (e2)\r\n  static positionToNotation(pos: Position): string {\r\n    const file = String.fromCharCode('a'.charCodeAt(0) + pos.col);\r\n    const rank = String(8 - pos.row);\r\n    return `${file}${rank}`;\r\n  }\r\n\r\n  // Lấy quân cờ tại vị trí\r\n  static getPieceAt(board: string[][], pos: Position): string {\r\n    if (pos.row < 0 || pos.row > 7 || pos.col < 0 || pos.col > 7) return '';\r\n    return board[pos.row][pos.col];\r\n  }\r\n\r\n  // Kiểm tra nước đi hợp lệ (cơ bản)\r\n  static isValidMove(\r\n    board: string[][],\r\n    move: Move,\r\n    playerColor: 'white' | 'black'\r\n  ): { valid: boolean; error?: string } {\r\n    const fromPiece = this.getPieceAt(board, move.from);\r\n    const toPiece = this.getPieceAt(board, move.to);\r\n\r\n    // Kiểm tra quân cờ nguồn\r\n    if (!this.isPlayerPiece(fromPiece, playerColor)) {\r\n      return { valid: false, error: 'Không phải quân cờ của bạn' };\r\n    }\r\n\r\n    // Không thể ăn quân cờ cùng màu\r\n    if (toPiece !== '.' && this.isPlayerPiece(toPiece, playerColor)) {\r\n      return { valid: false, error: 'Không thể ăn quân cờ của mình' };\r\n    }\r\n\r\n    // Kiểm tra theo từng loại quân\r\n    const pieceType = fromPiece.toLowerCase();\r\n    let isValid = false;\r\n\r\n    switch (pieceType) {\r\n      case 'p':\r\n        isValid = this.isValidPawnMove(board, move, playerColor);\r\n        break;\r\n      case 'r':\r\n        isValid = this.isValidRookMove(board, move);\r\n        break;\r\n      case 'n':\r\n        isValid = this.isValidKnightMove(move);\r\n        break;\r\n      case 'b':\r\n        isValid = this.isValidBishopMove(board, move);\r\n        break;\r\n      case 'q':\r\n        isValid = this.isValidQueenMove(board, move);\r\n        break;\r\n      case 'k':\r\n        isValid = this.isValidKingMove(move);\r\n        break;\r\n    }\r\n\r\n    if (!isValid) {\r\n      return { valid: false, error: 'Nước đi không hợp lệ' };\r\n    }\r\n\r\n    return { valid: true };\r\n  }\r\n\r\n  // Kiểm tra đường đi có bị chặn không\r\n  static isPathClear(board: string[][], from: Position, to: Position): boolean {\r\n    const rowDir = Math.sign(to.row - from.row);\r\n    const colDir = Math.sign(to.col - from.col);\r\n    \r\n    let currentRow = from.row + rowDir;\r\n    let currentCol = from.col + colDir;\r\n\r\n    while (currentRow !== to.row || currentCol !== to.col) {\r\n      if (board[currentRow][currentCol] !== '.') return false;\r\n      currentRow += rowDir;\r\n      currentCol += colDir;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // Tốt (Pawn)\r\n  static isValidPawnMove(board: string[][], move: Move, playerColor: 'white' | 'black'): boolean {\r\n    const direction = playerColor === 'white' ? -1 : 1;\r\n    const startRow = playerColor === 'white' ? 6 : 1;\r\n    const rowDiff = move.to.row - move.from.row;\r\n    const colDiff = Math.abs(move.to.col - move.from.col);\r\n\r\n    // Di chuyển thẳng\r\n    if (colDiff === 0) {\r\n      if (rowDiff === direction && board[move.to.row][move.to.col] === '.') {\r\n        return true;\r\n      }\r\n      // Nước đầu tiên có thể đi 2 ô\r\n      if (move.from.row === startRow && rowDiff === 2 * direction) {\r\n        const middleRow = move.from.row + direction;\r\n        return board[middleRow][move.from.col] === '.' && board[move.to.row][move.to.col] === '.';\r\n      }\r\n    }\r\n\r\n    // Ăn chéo\r\n    if (colDiff === 1 && rowDiff === direction) {\r\n      return board[move.to.row][move.to.col] !== '.';\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  // Xe (Rook)\r\n  static isValidRookMove(board: string[][], move: Move): boolean {\r\n    const rowDiff = Math.abs(move.to.row - move.from.row);\r\n    const colDiff = Math.abs(move.to.col - move.from.col);\r\n    \r\n    if ((rowDiff === 0 && colDiff > 0) || (colDiff === 0 && rowDiff > 0)) {\r\n      return this.isPathClear(board, move.from, move.to);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Mã (Knight)\r\n  static isValidKnightMove(move: Move): boolean {\r\n    const rowDiff = Math.abs(move.to.row - move.from.row);\r\n    const colDiff = Math.abs(move.to.col - move.from.col);\r\n    return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);\r\n  }\r\n\r\n  // Tượng (Bishop)\r\n  static isValidBishopMove(board: string[][], move: Move): boolean {\r\n    const rowDiff = Math.abs(move.to.row - move.from.row);\r\n    const colDiff = Math.abs(move.to.col - move.from.col);\r\n    \r\n    if (rowDiff === colDiff && rowDiff > 0) {\r\n      return this.isPathClear(board, move.from, move.to);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Hậu (Queen)\r\n  static isValidQueenMove(board: string[][], move: Move): boolean {\r\n    return this.isValidRookMove(board, move) || this.isValidBishopMove(board, move);\r\n  }\r\n\r\n  // Vua (King)\r\n  static isValidKingMove(move: Move): boolean {\r\n    const rowDiff = Math.abs(move.to.row - move.from.row);\r\n    const colDiff = Math.abs(move.to.col - move.from.col);\r\n    return rowDiff <= 1 && colDiff <= 1 && (rowDiff > 0 || colDiff > 0);\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}